% Fast S-expression DCG
% Alex Grabowski <alex.grabowski.a@gmail.com>
% 27.10.2021

% Handles quite strict dialect of S-expressions that is useful for PDDL
% generation.

% I've decided to write this S-expr grammar, because the one I found at
% [https://hackage.haskell.org/package/cpsa] wasn't a good fit. It relied on
% SWI-Prolog extensions, didn't work with `set_prolog_flag(double_quotes, chars)`
% and more importantly didn't terminate on my inputs.

% TODO: Test if it is portable to other Prolog implementations
% TODO: There should be a special 2nd order predicate that will generalize all this runtime var/1 checks

:- module(sexpr, [sexpr_chars/2, sexpr_atom/2]).
:- set_prolog_flag(double_quotes, chars).
:- initialization(ut_sexpr_tests_are_passing).

eval(_A, _B) :-
    % If it is know that A may throw an exception then reorder A and B.
    false.

sexpr_chars(S, L) :- phrase(sexpr(S), L).

sexpr_atom(S, A) :- atom(A) -> sexpr_atom_atom(S, A).
sexpr_atom(S, A) :- var(A) -> sexpr_atom_var(S, A).
sexpr_atom(_, A) :- compound(A) -> throw(type_error(atom|var, A)).
sexpr_atom_atom(S, A) :- atom_chars(A, L), sexpr_chars(S, L).
sexpr_atom_var(S, A) :- length(L, _), sexpr_chars(S, L), atom_chars(A, L).

sexpr(L) --> "(", expr_list(L), ")".

expr_list([H|T]) --> expression(H), expr_list_aux(T).
expr_list([]) --> "".
expr_list_aux(L) --> ({ ground(L) }, expr_list_chk(L), !) | expr_list_gen(L).
% WARN: Order is important for speed
expr_list_gen([]) --> "".
expr_list_gen([H|T]) --> " ", expression(H), expr_list_gen(T).
expr_list_chk([H|T]) --> " ", expression(H), expr_list_chk(T).
expr_list_chk([]) --> "".

expression(E) --> ({ ground(E) }, expression_chk(E), !) | expression_gen(E).
expression_gen(E) --> word(E) | variable(E) | sexpr(E).
expression_chk(E) --> (word(E) | variable(E) | sexpr(E)), !.

variable(A) --> "?", word(A).
word(A) --> ({ ground(A) }, word_chk(A), !) | word_gen(A).
% WARN: Order is important for speed
word_chk([H|T]) --> alpha(H), alnum_list(T).
word_gen([H|T]) --> alpha(H), alnum_list(T).

alnum_list(L) --> ({ ground(L) }, alnum_list_chk(L), !) | alnum_list_gen(L).
% WARN: Order is important for speed
alnum_list_gen([]) --> "".
alnum_list_gen([H|T]) --> alnum(H), alnum_list_gen(T).
alnum_list_chk([H|T]) --> alnum(H), alnum_list_chk(T), !.
alnum_list_chk([]) --> "".

% Order is important to speed-up greedy match
wss --> ws, wss.
wss --> "".
ws --> [C], { xws(C) }.
xws(' ').
xws('\t').
xws('\n').
xws('\r').

alnum(C) --> char(alnum, C).
numeric(C) --> char(numer, C).
alpha(C) --> char(alpha, C).
char(Class, C) --> [C], { ychar(Class, C) }.
ychar(numer, C) :- xchar(1,_,_, C).
ychar(alpha, C) :- xchar(_,1,_, C).
ychar(alnum, C) :- xchar(_,_,1, C).
xchar(1,0,1,'0').
xchar(1,0,1,'1').
xchar(1,0,1,'2').
xchar(1,0,1,'3').
xchar(1,0,1,'4').
xchar(1,0,1,'5').
xchar(1,0,1,'6').
xchar(1,0,1,'7').
xchar(1,0,1,'8').
xchar(1,0,1,'9').
xchar(0,1,1,'a').
xchar(0,1,1,'b').
xchar(0,1,1,'c').
xchar(0,1,1,'d').
xchar(0,1,1,'e').
xchar(0,1,1,'f').
xchar(0,1,1,'g').
xchar(0,1,1,'h').
xchar(0,1,1,'i').
xchar(0,1,1,'j').
xchar(0,1,1,'k').
xchar(0,1,1,'l').
xchar(0,1,1,'m').
xchar(0,1,1,'n').
xchar(0,1,1,'o').
xchar(0,1,1,'p').
xchar(0,1,1,'q').
xchar(0,1,1,'r').
xchar(0,1,1,'s').
xchar(0,1,1,'t').
xchar(0,1,1,'u').
xchar(0,1,1,'v').
xchar(0,1,1,'w').
xchar(0,1,1,'x').
xchar(0,1,1,'y').
xchar(0,1,1,'z').
xchar(0,1,0,'='). % Fix character class

% TODO: Fix this test
ut_sexpr_handles_empty_lists :-
    phrase(sexpr([[]]), ['('|T]), T = "())",
    phrase(sexpr(['']), _).

ut_sexpr_more_tests :-
    phrase(sexpr([exists, [_]]), "(exists (a))").

ut_sexpr_alnum_list_is_deterministic :-
    findall(L, phrase(alnum_list(L), "hello"), ["hello"]),
    findall([W,o,R,L,D], phrase(alnum_list([w,o,R,L,D]), [W,o,r,l,d]), ["world"]),
    findall(L, phrase(alnum_list("abc987"), L), ["abc987"]).
ut_sexpr_alnum_list_generates :-
    phrase(alnum_list(_), _), !.
ut_sexpr_alnum_is_deterministic :-
    findall(L, phrase(alnum(L), "a"), [a]).
ut_sexpr_alnum_always_terminates :-
    findall(_, phrase(alnum(_), _), _).

ut_sexpr_tests_are_passing :-
    ut_sexpr_alnum_is_deterministic,
    ut_sexpr_alnum_always_terminates,
    ut_sexpr_alnum_list_is_deterministic,
   %ut_sexpr_handles_empty_lists,
    ut_sexpr_alnum_list_generates.
