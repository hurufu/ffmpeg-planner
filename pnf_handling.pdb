:- set_prolog_flag(double_quotes, chars).
:- initialization(all_tests_are_passing).

:- use_module(library(dif)).

main(AcePnfFile) :-
    consult(AcePnfFile),
    pnf(AcePnf),
    pnf_pddl(AcePnf, ProblemDefinition),
    write(ProblemDefinition).

pnf_pddl(AcePnf, ProblemDefinition) :-
    u(AcePnf, Formula, ObjectList),
    phrase(pddl(ObjectList,Formula), PddlChars),
    atom_chars(ProblemDefinition, PddlChars).

% Unifies FOL formula with an equivalent one with all similar operators condensed
% Extract all named entities to :objects
% Unifies FOL formula in S-expr format with equivalent one where all 'be'
% predicates are replaced with '='
u(exists(A,B), e(  [i(A)], a(X)), O) :-
    must_be_variable(A),
    u(B, a(X), O).
u(exists(A,B), e([i(A)|J],    X), O) :-
    must_be_variable(A),
    u(B, e(J, X), O),
    differs_from_all(i(A), J).
u(&(A,B), a([AO,BO]), O) :- is_o(A, AO, AOO), is_o(B, BO, BOO), append(AOO, BOO, O).
u(&(A,B), a([AO,BP]), O) :- is_o(A, AO, AOO), is_p(B, BP, BOO), append(AOO, BOO, O).
u(&(A,B), a([AP,BO]), O) :- is_p(A, AP, AOO), is_o(B, BO, BOO), append(AOO, BOO, O).
u(&(A,B), a([AP,BP]), O) :- is_p(A, AP, AOO), is_p(B, BP, BOO), append(AOO, BOO, O).
u(&(A,B), a([AO|AX]), O) :- is_o(A, AO, AOO), u(B, a(AX), OT), append(AOO, OT, O).
u(&(A,B), a([AP|AX]), O) :- is_p(A, AP, AOO), u(B, a(AX), OT), append(AOO, OT, O).

is_o(object(_,A,P,_,_,_,_)-_/_, o(P,X), AO) :-
    tag(A, X, AO).
is_p(predicate(_,_,be,A,B)-_/_, p(=,X,Y), O) :-
    tag(A, X, AO),
    tag(B, Y, BO),
    append(AO, BO, O).
is_p(predicate(_,_,P,A,B)-_/_, p(P,X,Y), O) :-
    dif(=, P),
    dif(be, P),
    tag(A, X, AO),
    tag(B, Y, BO),
    append(AO, BO, O).
tag(A, X, O) :- var(A) -> tag_variable(A,X,O); tag_term(A,X,O).
tag_variable(A, i(A), []).
tag_term(named(A), n(A), [n(A)]).
tag_term(string(A), s(A), [s(A)]).

differs_from_all(A, L) :- maplist(dif(A), L).
must_be_variable(A) :- nonvar(A) -> throw(type_error(var,A)); true.

pddl(O,G) --> "(define (problem test)", n,
              "        (:domain ffmpeg)", n,
              "        ", objects(O), n,
              "        (:init ", predefined_init, ")", n,
              "        ", goal(G), ")", n.
n --> "\n".
objects(V) --> "(:objects", sequence_of_objects_spaced(V), predefined_objects, ")".
goal(G) --> "(:goal", prefix(G), ")".

prefix(e(P, M)) --> " (exists", list_of_variables(P), matrix(M), ")".

predefined_objects --> " f0 sample_mp4".
predefined_init --> "(file f0) (name sample_mp4) (have f0 sample_mp4)".
sequence_of_objects_spaced([]) --> "".
sequence_of_objects_spaced([O|T]) --> " ", identifier(O), sequence_of_objects_spaced(T).

matrix(a(L)) --> " (and", expression_list(L), ")".

expression_list([]) --> "".
expression_list([H|T]) --> " (", expression(H), ")", expression_list(T).
expression(o(O,A)) --> { atom_chars(O,OC) }, OC, identifier(A).
expression(p(P,A,B)) --> { atom_chars(P, PC) }, PC, identifier(A), identifier(B).

identifier(i(V)) --> " ", variable(V).
identifier(n(V)) --> " ", { atom_chars(V, VC) }, VC.
identifier(s(V)) --> " ", { filename_adjusted(V, VC) }, VC.

list_of_variables([i(H)|T]) --> " (", variable(H), list_of_variables_spaced(T), ")".
list_of_variables_spaced([]) --> "".
list_of_variables_spaced([i(H)|T]) --> " ", variable(H), list_of_variables_spaced(T).

variable(A) --> "?", alpha(A).

alnum(C) --> char(alnum, C).
numeric(C) --> char(numer, C).
alpha(C) --> char(alpha, C).
char(Class, C) --> [C], { ychar(Class, C) }.
ychar(numer, C) :- xchar(1,_,_, C).
ychar(alpha, C) :- xchar(_,1,_, C).
ychar(alnum, C) :- xchar(_,_,1, C).
xchar(1,0,1,'0').
xchar(1,0,1,'1').
xchar(1,0,1,'2').
xchar(1,0,1,'3').
xchar(1,0,1,'4').
xchar(1,0,1,'5').
xchar(1,0,1,'6').
xchar(1,0,1,'7').
xchar(1,0,1,'8').
xchar(1,0,1,'9').
xchar(0,1,1,'a').
xchar(0,1,1,'b').
xchar(0,1,1,'c').
xchar(0,1,1,'d').
xchar(0,1,1,'e').
xchar(0,1,1,'f').
xchar(0,1,1,'g').
xchar(0,1,1,'h').
xchar(0,1,1,'i').
xchar(0,1,1,'j').
xchar(0,1,1,'k').
xchar(0,1,1,'l').
xchar(0,1,1,'m').
xchar(0,1,1,'n').
xchar(0,1,1,'o').
xchar(0,1,1,'p').
xchar(0,1,1,'q').
xchar(0,1,1,'r').
xchar(0,1,1,'s').
xchar(0,1,1,'t').
xchar(0,1,1,'u').
xchar(0,1,1,'v').
xchar(0,1,1,'w').
xchar(0,1,1,'x').
xchar(0,1,1,'y').
xchar(0,1,1,'z').

% TODO: Remove duplicated predicates
% Workaround for not supported strings in PDDL
% Replaces last "_" with "."
filename_adjusted(GoodFileNameAtom, PddlFileNameChars) :-
    atom_chars(GoodFileNameAtom, GoodFileNameChars),
    phrase(adjust(GoodFileNameChars), PddlFileNameChars).

adjust(X) --> dirname(D), basename(B), "_", suffix(S), { append([D,B,".",S], X) }.
dirname([]) --> "". % Not implemented.
basename([]) --> "".
basename([H|T]) --> [H], basename(T).
suffix("mp4") --> "mp4".
suffix("mp3") --> "mp3".
suffix("mkv") --> "mkv".
suffix("avi") --> "avi".
suffix("ogg") --> "ogg".
suffix("webm") --> "webm".
suffix("webp") --> "webp".

% UT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

test(S, P, T, Y) :-
    S = 'p:f0 is a file which has a name which is "hello.mkv"',
    P = exists(A,exists(B,exists(C,exists(D,exists(E,
        &(
            object(F,A,file,countable,na,eq,1)-1/6,
            &(
                object(F,B,name,countable,na,eq,1)-1/10,
                &(
                    predicate(F,C,be,B,string('hello.mkv'))-1/12,
                    &(
                        predicate(F,D,have,A,B)-1/8,
                        predicate(F,E,be,named(f0),A)-1/4))))))))),
    T = [exists, [A, B, C, D, E],
                 [and, [file, A],
                       [name, B],
                       [=, B, 'hello_mkv'],
                       [have, A, B],
                       [=, f0, A]]],
    Y = e([i(A),i(B),i(C),i(D),i(E)],
          a([o(file, i(A)),
             o(name, i(B)),
             p(=, i(B), s('hello_mkv')),
             p(have, i(A), i(B)),
             p(=, n(f0), i(A))])).

ut_fol_sanity_checks_are_passing :-
     test(_,P,_,X), u(P,X,O), phrase(pddl(O,X), _), !.

all_tests_are_passing :-
     ut_fol_sanity_checks_are_passing.
